《计算机图形学》
实 验 报 告
学 号： 2023112573
姓 名： ln1
年 级： 2023 级
专 业： 软件工程
院 系： 计算机与人工智能学院
二〇二五年十一月
目录
一、 实验目的 ................................................................................................................................................ 3
二、 实验任务与要求 .................................................................................................................................... 3
三、 实验环境 ................................................................................................................................................ 4
四、 界面设计及交互方式 ............................................................................................................................ 4
4.1 主界面设计 ......................................................................................................................................................... 4
4.2 菜单结构 ............................................................................................................................................................. 5
4.3 交互方式设计： ................................................................................................................................................ 5
4.3.1 直线绘制 ..................................................................................................................................................... 5
4.3.2 圆的绘制 ..................................................................................................................................................... 5
4.3.3 矩形绘制 ..................................................................................................................................................... 6
4.3.4 多段线绘制 ................................................................................................................................................ 6
4.3.5 B样条曲线绘制 ......................................................................................................................................... 7
4.3.6 扫描线填充 ................................................................................................................................................ 7
4.3.7 边界填充 ..................................................................................................................................................... 8
五、 功能模块结构及说明 ............................................................................................................................ 9
5.1 系统架构 ............................................................................................................................................................. 9
5.2 类结构 .................................................................................................................................................................. 9
5.3 功能模块说明................................................................................................................................................... 10
5.3.1 主程序模块（ ComputerGraphics.cpp） ......................................................................................... 10
5.3.2 图形引擎模块（ GraphicsEngine类） ............................................................................................ 10
5.3.3 绘图算法模块 .......................................................................................................................................... 10
5.3.4 填充算法模块 .......................................................................................................................................... 10
5.3.5 用户交互模块 .......................................................................................................................................... 10
六、 算法流程图及说明： .......................................................................................................................... 11
6.1 DDA 直线算法 .................................................................................................................................................... 11
6.2 BRESENHAM 直线算法 .......................................................................................................................................... 12
6.3 中点圆算法 ....................................................................................................................................................... 13
6.4 BRESENHAM 圆算法 .............................................................................................................................................. 14
6.5 B 样条曲线算法 ............................................................................................................................................... 15
6.6 扫描线填充算法 .............................................................................................................................................. 16
6.7 边界填充算法（种子填充算法） ............................................................................................................... 17
七、 核心代码及注释 .................................................................................................................................. 17
7.1 DDA 直线算法实现 ........................................................................................................................................... 17
7.2 直线算法实现................................................................................................................................................... 18
7.3 中点圆算法实现 .............................................................................................................................................. 19
7.4 BRESENHAM 圆算法实现...................................................................................................................................... 20
7.5 B 样条曲线实现 ............................................................................................................................................... 20
7.6 扫描线填充算法实现 ..................................................................................................................................... 22
7.7 边界填充算法实现 .......................................................................................................................................... 23
7.8 鼠标事件处理................................................................................................................................................... 25
八、 软件使用说明 ...................................................................................................................................... 28
8.1 系统要求 ........................................................................................................................................................... 28
8.2 编译与运行 ....................................................................................................................................................... 28
8.3 功能使用指南................................................................................................................................................... 28
8.3.1 绘制直线 ................................................................................................................................................... 28
8.3.2 绘制圆 ....................................................................................................................................................... 28
8.3.3 绘制矩形 ................................................................................................................................................... 28
8.3.4 绘制多段线 .............................................................................................................................................. 29
8.3.5 绘制B样条曲线...................................................................................................................................... 29
8.3.6 扫描线填充 .............................................................................................................................................. 29
8.3.7 边界填充 ................................................................................................................................................... 29
8.3.8 清空画布 ................................................................................................................................................... 29
8.3.9 查看程序信息 .......................................................................................................................................... 29
九、 实验总结 .............................................................................................................................................. 30
9.1 实验成果 ........................................................................................................................................................... 30
9.2 技术收获 ........................................................................................................................................................... 30
9.3 遇到的问题及解决 .......................................................................................................................................... 30
9.4 心得体会 ........................................................................................................................................................... 31
一、 实验目的
本实验旨在通过设计与实现一个简单的图形绘制软件，掌握计算机图形学中基本
图形生成算法的原理与实现方法。通过实验，学生能够深入理解图形在计算机屏幕上
的表示方式、像素与坐标的对应关系，以及直线、圆、多边形等基本图形的绘制原
理。
此外，实验还要求学生在实现过程中综合运用算法思想与编程技巧，提升对中点
法、Bresenham 算法、扫描线填充法、栅栏填充法及 B样条曲线等图形学核心算法的理
解与应用能力。
通过实验，学生应具备以下能力：
1. 掌握基本图形生成算法的数学原理与计算步骤；
2. 能够利用鼠标交互完成图形绘制；
3. 能够设计具有一定功能性的图形编辑界面；
4. 能够实现不同算法的对比与优化；
5. 具备将图形学算法应用于实际软件开发的综合实践能力。
二、 实验任务与要求
1. 设计并实现一个简单的图形绘制软件，主要包括以下功能：
用户可通过点击菜单项或者工具条按钮实现基本图形的绘制。基本图形包括：直
线、曲线、圆、矩形、多段线等。图形的参数通过鼠标输入。比如，当用户点击“直
线”绘制按钮或菜单项时，可通过在绘制区第一次点击鼠标左键确定直线的起点，然
后移动鼠标，在另一个位置点击鼠标左键确定直线终点，从而绘制出一条直线段。其
他图形的绘制方式请参照相关软件自行设计。
(1) 添加菜单项或者工具条按钮，分别采用中点法和 Bresenham 算法实现
直线段的绘制。
(2) 添加菜单项或者工具条按钮，分别采用中点法和 Bresenham 算法实现
圆的绘制。
(3) 添加菜单项或者工具条按钮，采用扫描线法和栅栏填充法实现对封闭
区域（比如圆，矩形，用多段线绘制的闭合三角形或者多边形等）进行填充。
(4) 添加菜单项或者工具条按钮，通过多个控制点绘制连续的 B样条曲
线。
2. 撰写报告，主要包括如下几个部分的内容：
(1) 给出本次实验的目的，任务及要求等。
(2) 设计相应的界面及交互方式满足上述实验要求。
(3) 给出满足上述实验要求的功能模块结构图及功能说明。
(4) 给出实现上述实验要求的算法的程序流程图及说明。
(5) 编写程序实现上述实验要求，并给出核心代码及其注释。
(6) 给出软件的用户使用说明。
(7) 实验总结。
三、 实验环境
硬件环境:
处理器: AMD Ryzen 7 7700
内 存: 32GB RAM
软件环境:
操作系统: Windows 11 Pro 64 位
开发工具: Microsoft Visual Studio 2022
四、 界面设计及交互方式
4.1 主界面设计
本程序采用 Windows桌面应用程序架构，主窗口包含菜单栏和绘图区域。
图表 1主界面设计
4.2 菜单结构
图表 2-菜单结构
4.3 交互方式设计：
4.3.1 直线绘制
1. 点击菜单选择算法（DDA或Bresenham）
2. 在画布上点击鼠标左键确定起点
3. 移动鼠标到终点位置
4. 再次点击鼠标左键确定终点，完成绘制
图表 3-绘制直线
4.3.2 圆的绘制
1. 点击菜单选择算法（中点或 Bresenham）
2. 在画布上点击鼠标左键确定圆心
3. 移动鼠标确定半径
4. 再次点击鼠标左键，完成圆的绘制
图表 4-绘制圆
4.3.3 矩形绘制
1. 点击"矩形"菜单项
2. 点击鼠标左键确定矩形的一个顶点
3. 移动鼠标到对角顶点
4. 再次点击鼠标左键，完成矩形绘制
图表 5-绘制矩形
4.3.4 多段线绘制
1. 点击"多段线"菜单项
2. 依次点击鼠标左键添加顶点
3. 点击鼠标右键结束绘制
图表 6-多段线绘制
4.3.5 B样条曲线绘制
1. 点击"B 样条曲线"菜单项
2. 依次点击 4个或更多控制点
3. 程序自动绘制平滑的 B样条曲线
图表 7-B 样条曲线绘制
4.3.6 扫描线填充
1. 点击"扫描线填充"菜单项
2. 依次点击鼠标左键定义多边形顶点（至少 3个）
3. 点击鼠标右键结束，程序自动填充多边形
图表 8-扫描线填充
4.3.7 边界填充
1. 先绘制一个封闭图形（如圆、矩形等）
2. 点击"边界填充"菜单项
3. 在封闭图形内部点击鼠标左键，程序自动填充
图表 9-边界填充
五、 功能模块结构及说明
5.1 系统架构
图表 10-系统架构图
5.2 类结构
图表 11-类结构图
5.3 功能模块说明
5.3.1 主程序模块（ComputerGraphics.cpp）
功能：程序入口，窗口创建，消息循环处理
职责：
⚫ 创建主窗口和菜单
⚫ 处理 Windows消息（WM_CREATE, WM_PAINT, WM_COMMAND 等）
⚫ 响应菜单点击事件
⚫ 处理鼠标事件并转发给图形引擎
5.3.2 图形引擎模块（GraphicsEngine类）
功能：核心绘图引擎
职责：
⚫ 心绘图引擎，管理绘图状态和调度算法
⚫ 维护当前绘图模式
⚫ 管理临时点集合
⚫ 处理鼠标输入并转换为图形参数
⚫ 调用相应的绘图算法
⚫ 管理设备上下文（HDC）
5.3.3 绘图算法模块
包含以下子模块：
直线绘制模块
⚫ DrawLineDDA(): DDA 算法实现
⚫ DrawLineBresenham(): Bresenham 算法实现
圆绘制模块
⚫ DrawCircleMidpoint(): 中点圆算法实现
⚫ DrawCircleBresenham(): Bresenham 圆算法实现基本图形模块
⚫ DrawRectangle(): 矩形绘制
⚫ DrawPolyline(): 多段线绘制
⚫ DrawBSpline(): B 样条曲线绘制
5.3.4 填充算法模块
⚫ ScanlineFill(): 扫描线填充算法
⚫ BoundaryFill(): 边界填充算法（种子填充）
5.3.5 用户交互模块
⚫ 鼠标事件处理（OnLButtonDown, OnRButtonDown, OnMouseMove）
⚫ 菜单命令处理
⚫ 模式切换管理
六、 算法流程图及说明：
6.1 DDA 直线算法
图表 12-DDA 直线算法流程图
算法说明：
• DDA（Digital Differential Analyzer）算法是一种增量算法
• 通过计算每步的增量来逐点绘制直线
• 优点：简单直观，易于理解
• 缺点：涉及浮点运算，速度较慢
6.2 Bresenham 直线算法
图表 13-Breseham直线算法流程图
算法说明：
• Bresenham 算法只使用整数运算，效率高
• 通过误差累积判断下一个点的位置
• 优点：速度快，精度高
• 应用：广泛用于图形硬件和软件
6.3 中点圆算法
图表 14-中点圆算法流程图
算法说明：
• 利用圆的 8对称性，只需计算 1/8 圆弧
• 通过判别式决定下一个点的位置
• 只使用整数加法运算，效率高
6.4 Bresenham 圆算法
图表 15-Bresenham 圆算法流程图
算法说明：
• 与中点圆算法类似，但判别式计算方式不同
• 同样利用圆的 8对称性
• 整数运算，效率高
6.5 B 样条曲线算法
图表 16-B样条曲线算法
算法说明：
• B 样条曲线是一种参数曲线
• 通过控制点和基函数计算曲线上的点
• 具有局部控制性，修改一个控制点只影响局部曲线
• 曲线不一定经过控制点
6.6 扫描线填充算法
图表 17-扫描线填充算法流程图
算法说明：
• 从下到上逐行扫描多边形
• 计算扫描线与多边形边的交点
• 交点两两配对，填充之间的像素
• 适用于任意多边形的填充
6.7 边界填充算法（种子填充算法）
图表 18-种子填充算法流程图
算法说明：
• 从种子点开始向四周扩散填充
• 使用栈避免递归导致的栈溢出
• 采用扫描线优化，提高填充效率
• 遇到边界色停止扩散
七、 核心代码及注释
7.1 DDA 直线算法实现
void GraphicsEngine::DrawLineDDA(Point2D p1, Point2D p2, COLORREF color)
{
// 计算 x和y方向的增量
int dx = p2.x - p1.x;
int dy = p2.y - p1.y;
// 确定步数：取 dx和 dy中的较大值
int steps = abs(dx) > abs(dy) ? abs(dx) : abs(dy);
if (steps == 0) return; // 起点和终点重合
// 计算每步的增量
float xIncrement = (float)dx / steps;
float yIncrement = (float)dy / steps;
// 初始化当前点为起点
float x = (float)p1.x;
float y = (float)p1.y;
// 逐步绘制直线上的点
for (int i = 0; i <= steps; i++)
{
// 四舍五入并绘制点
SetPixel((int)(x + 0.5), (int)(y + 0.5), color);
x += xIncrement; // x坐标递增
y += yIncrement; // y坐标递增
}
}
7.2 直线算法实现
void GraphicsEngine::DrawLineBresenham(Point2D p1, Point2D p2, COLORREF color)
{
// 计算 x和y方向的绝对增量
int dx = abs(p2.x - p1.x);
int dy = abs(p2.y - p1.y);
// 确定步进方向（1或-1）
int sx = p1.x < p2.x ? 1 : -1;
int sy = p1.y < p2.y ? 1 : -1;
// 初始化误差项
int err = dx - dy;
int x = p1.x;
int y = p1.y;
while (true)
{
SetPixel(x, y, color); // 绘制当前点
if (x == p2.x && y == p2.y) break; // 到达终点
int e2 = 2 * err; // 误差的两倍
// 根据误差决定下一步的方向
if (e2 > -dy)
{
err -= dy;
x += sx; // x方向步进
}
if (e2 < dx)
{
err += dx;
y += sy; // y方向步进
}
}
}
7.3 中点圆算法实现
void GraphicsEngine::DrawCircleMidpoint(Point2D center, int radius, COLORREF color)
{
int x = 0;
int y = radius;
int d = 1 - radius; // 初始判别式
while (x <= y)
{
// 利用圆的8对称性绘制 8个点
SetPixel(center.x + x, center.y + y, color);
SetPixel(center.x - x, center.y + y, color);
SetPixel(center.x + x, center.y - y, color);
SetPixel(center.x - x, center.y - y, color);
SetPixel(center.x + y, center.y + x, color);
SetPixel(center.x - y, center.y + x, color);
SetPixel(center.x + y, center.y - x, color);
SetPixel(center.x - y, center.y - x, color);
// 根据判别式更新下一个点
if (d < 0)
{
d += 2 * x + 3; // 选择右边的点
}
else
{
d += 2 * (x - y) + 5; // 选择右下方的点
y--;
}
x++;
}
}
7.4 Bresenham 圆算法实现
void GraphicsEngine::DrawCircleBresenham(Point2D center, int radius, COLORREF color)
{
int x = 0;
int y = radius;
int d = 3 - 2 * radius; // 初始判别式
while (x <= y)
{
// 利用圆的8对称性绘制 8个点
SetPixel(center.x + x, center.y + y, color);
SetPixel(center.x - x, center.y + y, color);
SetPixel(center.x + x, center.y - y, color);
SetPixel(center.x - x, center.y - y, color);
SetPixel(center.x + y, center.y + x, color);
SetPixel(center.x - y, center.y + x, color);
SetPixel(center.x + y, center.y - x, color);
SetPixel(center.x - y, center.y - x, color);
// 根据判别式更新下一个点
if (d < 0)
{
d += 4 * x + 6;
}
else
{
d += 4 * (x - y) + 10;
y--;
}
x++;
}
}
7.5 B 样条曲线实现
void GraphicsEngine::DrawBSpline(const std::vector<Point2D>& controlPoints, COLORREF
color)
{
if (controlPoints.size() < 4) return; // 至少需要 4个控制点
const int segments = 100; // 曲线分段数
std::vector<Point2D> curvePoints;
// 计算曲线上的点
for (int i = 0; i <= segments; i++)
{
float t = (float)i / segments; // 参数 t从0到1
Point2D point = CalculateBSplinePoint(t, controlPoints);
curvePoints.push_back(point);
}
// 连接所有曲线点
DrawPolyline(curvePoints, color);
}
Point2D GraphicsEngine::CalculateBSplinePoint(float t, const std::vector<Point2D>&
controlPoints)
{
int n = static_cast<int>(controlPoints.size());
if (n < 4) return Point2D(0, 0);
// 计算当前参数对应的曲线段
float u = t * (n - 3);
int k = (int)u;
if (k >= n - 3) k = n - 4;
u = u - k; // 局部参数
// 计算 B样条基函数
float b0 = (1 - u) * (1 - u) * (1 - u) / 6;
float b1 = (3 * u * u * u - 6 * u * u + 4) / 6;
float b2 = (-3 * u * u * u + 3 * u * u + 3 * u + 1) / 6;
float b3 = u * u * u / 6;
// 计算曲线点坐标
Point2D result;
result.x = (int)(b0 * controlPoints[k].x + b1 * controlPoints[k+1].x +
b2 * controlPoints[k+2].x + b3 * controlPoints[k+3].x);
result.y = (int)(b0 * controlPoints[k].y + b1 * controlPoints[k+1].y +
b2 * controlPoints[k+2].y + b3 * controlPoints[k+3].y);
return result;
}
7.6 扫描线填充算法实现
void GraphicsEngine::ScanlineFill(const std::vector<Point2D>& polygon, COLORREF
fillColor)
{
if (polygon.size() < 3) return; // 至少需要 3个顶点
// 找到多边形的 y坐标范围
int minY = polygon[0].y, maxY = polygon[0].y;
for (size_t i = 0; i < polygon.size(); i++) {
if (polygon[i].y < minY) minY = polygon[i].y;
if (polygon[i].y > maxY) maxY = polygon[i].y;
}
// 创建画笔以提高绘制效率
HPEN hPen = CreatePen(PS_SOLID, 1, fillColor);
HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
// 对每条扫描线进行处理
for (int y = minY; y <= maxY; y++) {
std::vector<int> intersections; // 存储交点的 x坐标
// 计算扫描线与多边形各边的交点
for (size_t i = 0; i < polygon.size(); i++) {
Point2D p1 = polygon[i];
Point2D p2 = polygon[(i + 1) % polygon.size()]; // 下一个顶点
// 判断边是否与扫描线相交
if ((p1.y <= y && p2.y > y) || (p2.y <= y && p1.y > y)) {
// 计算交点的 x坐标
int x = p1.x + (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
intersections.push_back(x);
}
}
// 对交点按x坐标排序（冒泡排序）
for (size_t i = 0; i < intersections.size(); i++) {
for (size_t j = i + 1; j < intersections.size(); j++) {
if (intersections[i] > intersections[j]) {
int temp = intersections[i];
intersections[i] = intersections[j];
intersections[j] = temp;
}
}
}
// 填充交点之间的像素（使用 LineTo提高效率）
for (size_t i = 0; i + 1 < intersections.size(); i += 2) {
MoveToEx(hdc, intersections[i], y, NULL);
LineTo(hdc, intersections[i + 1], y);
}
}
// 恢复原画笔
SelectObject(hdc, hOldPen);
DeleteObject(hPen);
}
7.7 边界填充算法实现
void GraphicsEngine::BoundaryFill(int x, int y, COLORREF fillColor, COLORREF
boundaryColor)
{
RECT clientRect;
GetClientRect(hwnd, &clientRect);
// 检查起始点颜色
COLORREF startColor = GetPixel(x, y);
if (startColor == boundaryColor || startColor == fillColor) {
return; // 起始点在边界上或已填充
}
// 使用栈实现非递归填充
std::stack<Point2D> seedStack;
seedStack.push(Point2D(x, y));
int maxIterations = 100000; // 限制迭代次数防止卡死
int iterations = 0;
// 创建画笔提高绘制效率
HPEN hPen = CreatePen(PS_SOLID, 1, fillColor);
HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
while (!seedStack.empty() && iterations < maxIterations) {
Point2D seed = seedStack.top();
seedStack.pop();
iterations++;
// 边界检查
if (seed.x < 0 || seed.x >= clientRect.right ||
seed.y < 0 || seed.y >= clientRect.bottom) {
continue;
}
COLORREF c = GetPixel(seed.x, seed.y);
if (c == boundaryColor || c == fillColor) {
continue; // 遇到边界或已填充区域
}
// 找到当前扫描线的左右边界
int left = seed.x;
int right = seed.x;
// 向左扩展
while (left > 0) {
c = GetPixel(left - 1, seed.y);
if (c == boundaryColor || c == fillColor) break;
left--;
}
// 向右扩展
while (right < clientRect.right - 1) {
c = GetPixel(right + 1, seed.y);
if (c == boundaryColor || c == fillColor) break;
right++;
}
// 填充当前扫描线
MoveToEx(hdc, left, seed.y, NULL);
LineTo(hdc, right + 1, seed.y);
// 检查上下相邻扫描线，添加新的种子点
bool inSpan = false;
for (int i = left; i <= right; i++) {
// 检查上方扫描线
if (seed.y > 0) {
c = GetPixel(i, seed.y - 1);
if (c != boundaryColor && c != fillColor) {
if (!inSpan) {
seedStack.push(Point2D(i, seed.y - 1));
inSpan = true;
}
} else {
inSpan = false;
}
}
}
inSpan = false;
for (int i = left; i <= right; i++) {
// 检查下方扫描线
if (seed.y < clientRect.bottom - 1) {
c = GetPixel(i, seed.y + 1);
if (c != boundaryColor && c != fillColor) {
if (!inSpan) {
seedStack.push(Point2D(i, seed.y + 1));
inSpan = true;
}
} else {
inSpan = false;
}
}
}
}
// 恢复画笔
SelectObject(hdc, hOldPen);
DeleteObject(hPen);
// 超过迭代限制时提示用户
if (iterations >= maxIterations) {
MessageBox(hwnd, L"填充区域过大，已停止填充"
, L"提示"
, MB_OK |
MB_ICONWARNING);
}
}
7.8 鼠标事件处理
void GraphicsEngine::OnLButtonDown(int x, int y)
{
Point2D clickPoint(x, y);
switch (currentMode)
{
case MODE_LINE_DDA:
case MODE_LINE_BRESENHAM:
if (!isDrawing)
{
// 第一次点击：记录起点
tempPoints.clear();
tempPoints.push_back(clickPoint);
isDrawing = true;
}
else
{
// 第二次点击：记录终点并绘制
tempPoints.push_back(clickPoint);
if (currentMode == MODE_LINE_DDA)
DrawLineDDA(tempPoints[0], tempPoints[1]);
else
DrawLineBresenham(tempPoints[0], tempPoints[1]);
isDrawing = false;
}
break;
case MODE_CIRCLE_MIDPOINT:
case MODE_CIRCLE_BRESENHAM:
if (!isDrawing)
{
// 第一次点击：记录圆心
tempPoints.clear();
tempPoints.push_back(clickPoint);
isDrawing = true;
}
else
{
// 第二次点击：计算半径并绘制
tempPoints.push_back(clickPoint);
int radius = (int)sqrt(pow(tempPoints[1].x - tempPoints[0].x, 2) +
pow(tempPoints[1].y - tempPoints[0].y, 2));
if (currentMode == MODE_CIRCLE_MIDPOINT)
DrawCircleMidpoint(tempPoints[0], radius);
else
DrawCircleBresenham(tempPoints[0], radius);
isDrawing = false;
}
break;
case MODE_POLYLINE:
// 多段线：每次点击添加一个顶点
tempPoints.push_back(clickPoint);
if (!isDrawing) isDrawing = true;
break;
case MODE_BSPLINE:
// B样条：收集控制点
tempPoints.push_back(clickPoint);
if (!isDrawing) isDrawing = true;
if (tempPoints.size() >= 4)
{
// 达到4个控制点，绘制曲线
DrawBSpline(tempPoints);
tempPoints.clear();
isDrawing = false;
}
break;
case MODE_FILL_SCANLINE:
// 扫描线填充：收集多边形顶点
tempPoints.push_back(clickPoint);
if (!isDrawing) isDrawing = true;
if (tempPoints.size() >= 3)
{
// 实时显示多边形轮廓
DrawPolyline(tempPoints, RGB(0, 0, 0));
}
break;
case MODE_FILL_BOUNDARY:
// 边界填充：直接在点击位置填充
BoundaryFill(x, y, RGB(255, 0, 0), RGB(0, 0, 0));
break;
}
}
void GraphicsEngine::OnRButtonDown(int x, int y)
{
// 右键用于结束多段线和扫描线填充
if (currentMode == MODE_POLYLINE && tempPoints.size() >= 2)
{
DrawPolyline(tempPoints);
tempPoints.clear();
isDrawing = false;
}
else if (currentMode == MODE_FILL_SCANLINE && tempPoints.size() >= 3)
{
// 闭合多边形并填充
DrawPolyline(tempPoints, RGB(0, 0, 0));
ScanlineFill(tempPoints, RGB(255, 0, 0));
tempPoints.clear();
isDrawing = false;
}
}
八、 软件使用说明
8.1 系统要求
⚫ 操作系统：Windows 7 及以上版本
⚫ 开发环境：Visual Studio 2019/2022
⚫ 编译器：MSVC (Microsoft Visual C++)
⚫ 依赖库：Windows SDK
8.2 编译与运行
⚫ 使用 Visual Studio 打开 ComputerGraphics.sln 解决方案文件
⚫ 选择配置（Debug 或Release）和平台（x86或x64）
⚫ 按F5 或点击"开始调试"按钮编译并运行程序
8.3 功能使用指南
8.3.1 绘制直线
DDA 算法：
1. 点击菜单"绘图" → "直线（DDA算法）"
2. 在画布上点击鼠标左键确定起点
3. 移动鼠标到终点位置
4. 再次点击鼠标左键，完成直线绘制
Bresenham 算法：
1. 操作方式与 DDA算法相同
2. 点击菜单"绘图" → "直线（Bresenham 算法）"
8.3.2 绘制圆
中点算法：
1. 点击菜单"绘图" → "圆（中点算法）"
2. 在画布上点击鼠标左键确定圆心
3. 移动鼠标确定半径（圆心到鼠标的距离）
4. 再次点击鼠标左键，完成圆的绘制
Bresenham 算法：
1. 操作方式与中点算法相同
2. 点击菜单"绘图" → "圆（Bresenham 算法）"
8.3.3 绘制矩形
1. 点击菜单"绘图" → "矩形"
2. 点击鼠标左键确定矩形的一个顶点
3. 移动鼠标到对角顶点位置
4. 再次点击鼠标左键，完成矩形绘制
8.3.4 绘制多段线
1. 点击菜单"绘图" → "多段线（右键结束）"
2. 依次点击鼠标左键添加各个顶点
3. 点击鼠标右键结束绘制，程序自动连接所有顶点
8.3.5 绘制 B样条曲线
1. 点击菜单"绘图" → "B样条曲线（4个控制点）"
2. 依次点击 4个或更多控制点
3. 程序自动绘制平滑的 B样条曲线
4. 注意：至少需要 4个控制点才能绘制 B样条曲线
8.3.6 扫描线填充
1. 点击菜单"填充" → "扫描线填充（右键结束）"
2. 依次点击鼠标左键定义多边形的各个顶点（至少 3个）
3. 点击鼠标右键结束，程序自动：闭合多边形
4. 绘制多边形边界（黑色）
5. 填充多边形内部（红色）
6. 适用场景：填充任意多边形
8.3.7 边界填充
1. 先使用其他工具绘制一个封闭图形（如圆、矩形等）
2. 点击菜单"填充" → "边界填充"
3. 在封闭图形内部点击鼠标左键
4. 程序自动填充封闭区域（红色）
5. 注意事项：
6. 图形必须完全封闭，否则填充会溢出
7. 填充区域过大时会自动停止并提示
8. 边界颜色默认为黑色
8.3.8 清空画布
1. 点击菜单"文件" → "新建"
2. 或按快捷键 Ctrl+N
3. 画布将被清空，可以重新绘制
8.3.9 查看程序信息
1. 点击菜单"帮助" → "关于"
2. 显示程序信息、作者信息和实验内容
九、 实验总结
9.1 实验成果
本次实验成功实现了一个功能完整的图形绘制软件，主要成果包括：
算法实现：
⚫ 实现了 DDA和Bresenham 两种直线绘制算法
⚫ 实现了中点法和 Bresenham 两种圆绘制算法
⚫ 实现了扫描线填充和边界填充两种区域填充算法
⚫ 实现了 B样条曲线绘制算法
功能完善：
⚫ 支持多种基本图形的绘制（直线、圆、矩形、多段线、曲线）
⚫ 提供友好的图形用户界面
⚫ 支持鼠标交互式输入
⚫ 实现了菜单驱动的操作方式
性能优化：
⚫ 填充算法采用扫描线优化，避免逐像素操作
⚫ 使用 GDI的LineTo 函数提高绘制效率
⚫ 添加迭代次数限制，防止程序卡死
9.2 技术收获
算法理解：
⚫ 深入理解了各种图形生成算法的原理和实现细节
⚫ 掌握了增量算法的思想和优势
⚫ 理解了整数运算在图形算法中的重要性
编程能力：
⚫ 提高了 C++面向对象编程能力
⚫ 熟悉了 Windows API 和GDI 图形编程
⚫ 学会了使用 STL 容器和算法
软件工程：
⚫ 学会了模块化设计和代码组织
⚫ 掌握了事件驱动编程模式
⚫ 提高了代码调试和优化能力
9.3 遇到的问题及解决
性能问题：
问题：填充大面积区域时程序卡顿
解决：使用 LineTo 代替SetPixel，采用扫描线优化算法
栈溢出问题：
问题：递归边界填充导致栈溢出从而使程序崩溃
解决：改用非递归算法，使用 std::stack 管理种子点
编码问题：
交互设计：
问题：中文字符导致编译错误
解决：使用 Unicode 宽字符（L"..."）处理中文
问题：用户不知道如何结束多段线绘制
解决：在菜单项中添加提示"（右键结束）"
9.4 心得体会
通过本次实验，我深刻体会到：
理论与实践的结合：课堂上学习的算法原理，通过编程实现后有了更深刻的
理解。特别是 Bresenham 算法的巧妙之处，只有在实现过程中才能真正体会。
算法优化的重要性：初始实现的填充算法性能很差，频繁导致系统崩溃，通
过优化后性能提升了数十倍。这让我认识到算法选择和实现细节对程序性能的巨
大影响。
用户体验的价值：一个好的软件不仅要功能正确，还要易用。添加菜单提
示、错误处理等细节，大大提升了软件的可用性。
问题解决能力：在开发过程中遇到了很多问题，通过查阅资料、分析调试，
最终都得到了解决。这个过程锻炼了我的问题分析和解决能力。
软件工程思维：通过模块化设计、代码复用等方法，使程序结构清晰、易于
维护。这对今后的软件开发工作很有帮助。
总的来说，本次实验是一次非常有价值的学习经历，不仅巩固了计算机图形
学的理论知识，也提高了实际编程能力和软件工程素养。