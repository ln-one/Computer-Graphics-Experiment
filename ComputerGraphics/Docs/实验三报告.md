# 《计算机图形学》实验报告

## 实验三：基本图形变换和裁剪

**学号：** 2023112573  
**姓名：** 张春冉  
**年级：** 2023级  
**专业：** 软件工程  
**院系：** 计算机与人工智能学院  

**日期：** 2025年12月

---

## 目录

1. [实验目的](#一实验目的)
2. [实验任务与要求](#二实验任务与要求)
3. [实验环境](#三实验环境)
4. [界面设计及交互方式](#四界面设计及交互方式)
5. [功能模块结构及说明](#五功能模块结构及说明)
6. [算法流程图及说明](#六算法流程图及说明)
7. [核心代码及注释](#七核心代码及注释)
8. [软件使用说明](#八软件使用说明)
9. [实验总结](#九实验总结)

---

## 一、实验目的

本实验旨在通过设计与实现图形变换和裁剪功能，掌握计算机图形学中几何变换和图形裁剪的基本原理与实现方法。通过实验，学生能够深入理解：

1. **几何变换原理**：掌握平移、缩放、旋转等基本几何变换的数学原理和矩阵表示方法
2. **图形裁剪算法**：理解并实现多种经典裁剪算法，包括Cohen-Sutherland、中点分割、Sutherland-Hodgman和Weiler-Atherton算法
3. **图形对象管理**：学习如何设计和实现图形对象的存储、选择和管理机制
4. **交互式操作**：掌握如何通过鼠标交互实现图形的选择、变换和裁剪操作

通过实验，学生应具备以下能力：

1. 掌握齐次坐标和变换矩阵的使用方法
2. 能够实现多种直线和多边形裁剪算法
3. 能够设计面向对象的图形系统架构
4. 能够处理复杂的用户交互逻辑
5. 具备分析和优化图形算法性能的能力

---

## 二、实验任务与要求

### 2.1 基本要求

1. **图形对象管理**
   - 实现图形对象的存储和管理机制
   - 支持多种图形类型（直线、圆、矩形、多边形等）
   - 实现图形的选择和高亮显示功能

2. **几何变换功能**
   - 实现图形的平移变换
   - 实现图形的缩放变换（相对于图形中心）
   - 实现图形的旋转变换（绕指定点旋转）
   - 所有变换应支持实时预览

3. **直线裁剪算法**
   - 实现Cohen-Sutherland直线裁剪算法
   - 实现中点分割直线裁剪算法
   - 支持用户通过鼠标定义矩形裁剪窗口

4. **多边形裁剪算法**
   - 实现Sutherland-Hodgman多边形裁剪算法
   - 实现Weiler-Atherton多边形裁剪算法
   - 正确处理凸多边形和凹多边形的裁剪

### 2.2 报告要求


1. 给出本次实验的目的、任务及要求
2. 设计相应的界面及交互方式满足实验要求
3. 给出满足实验要求的功能模块结构图及功能说明
4. 给出实现实验要求的算法的程序流程图及说明
5. 编写程序实现实验要求，并给出核心代码及其注释
6. 给出软件的用户使用说明
7. 实验总结

---

## 三、实验环境

### 3.1 硬件环境

- **处理器：** AMD Ryzen 7 7700
- **内存：** 32GB RAM
- **显示器：** 1920×1080分辨率

### 3.2 软件环境

- **操作系统：** Windows 11 Pro 64位
- **开发工具：** Microsoft Visual Studio 2022
- **编程语言：** C++
- **图形API：** Windows GDI
- **编译器：** MSVC (Microsoft Visual C++)

---

## 四、界面设计及交互方式

### 4.1 主界面设计

本程序采用Windows桌面应用程序架构，主窗口包含菜单栏和绘图区域。在实验三中，新增了"变换"和"裁剪"菜单，用于实现图形的几何变换和裁剪操作。

主界面布局：
- **菜单栏**：包含文件、绘图、填充、变换、裁剪、帮助等菜单
- **绘图区域**：占据窗口主体，用于显示和操作图形
- **状态栏**：显示当前操作模式和提示信息（可选）

### 4.2 菜单结构

```
文件(F)
├── 新建(N)         Ctrl+N
└── 退出(X)

绘图(D)
├── 直线（DDA算法）
├── 直线（Bresenham算法）
├── 圆（中点算法）
├── 圆（Bresenham算法）
├── 矩形
├── 多段线（右键结束）
├── 多边形（右键结束）        [新增]
└── B样条曲线

填充(I)
├── 扫描线填充
└── 边界填充

变换(T)                        [新增菜单]
├── 选择图形
├── 平移
├── 缩放
└── 旋转

裁剪(C)                        [新增菜单]
├── 直线裁剪
│   ├── Cohen-Sutherland算法
│   └── 中点分割算法
└── 多边形裁剪
    ├── Sutherland-Hodgman算法
    └── Weiler-Atherton算法

帮助(H)
└── 关于(A)
```

### 4.3 交互方式设计

#### 4.3.1 多边形绘制

1. 点击菜单"绘图" → "多边形（右键结束）"
2. 在画布上依次点击鼠标左键添加多边形顶点
3. 移动鼠标时显示从上一个顶点到当前鼠标位置的预览线
4. 点击鼠标右键或双击左键完成绘制，程序自动闭合多边形

#### 4.3.2 图形选择

1. 点击菜单"变换" → "选择图形"
2. 在画布上点击要选择的图形
3. 被选中的图形会以高亮方式显示（如虚线边框）
4. 点击空白区域取消选择

#### 4.3.3 图形平移

1. 先选择一个图形
2. 点击菜单"变换" → "平移"
3. 在画布上点击鼠标左键确定起始位置
4. 拖动鼠标到目标位置，实时显示平移预览
5. 释放鼠标左键完成平移操作

#### 4.3.4 图形缩放

1. 先选择一个图形
2. 点击菜单"变换" → "缩放"
3. 点击鼠标左键确定缩放中心（默认为图形中心）
4. 向外拖动鼠标放大图形，向内拖动缩小图形
5. 释放鼠标左键完成缩放操作

#### 4.3.5 图形旋转

1. 先选择一个图形
2. 点击菜单"变换" → "旋转"
3. 点击鼠标左键确定旋转中心
4. 移动鼠标，图形会根据鼠标位置相对于旋转中心的角度进行旋转
5. 再次点击鼠标左键完成旋转操作

#### 4.3.6 直线裁剪（Cohen-Sutherland算法）

1. 点击菜单"裁剪" → "直线裁剪" → "Cohen-Sutherland算法"
2. 在画布上按住鼠标左键并拖动，定义矩形裁剪窗口
3. 拖动过程中显示虚线矩形预览
4. 释放鼠标后，程序自动对所有直线执行裁剪操作
5. 显示裁剪结果，保留窗口内的线段部分

#### 4.3.7 直线裁剪（中点分割算法）

操作方式与Cohen-Sutherland算法相同，但使用中点分割算法进行裁剪。

#### 4.3.8 多边形裁剪（Sutherland-Hodgman算法）

1. 点击菜单"裁剪" → "多边形裁剪" → "Sutherland-Hodgman算法"
2. 在画布上拖动鼠标定义矩形裁剪窗口
3. 释放鼠标后，程序自动对所有多边形执行裁剪操作
4. 显示裁剪结果，保留窗口内的多边形部分

#### 4.3.9 多边形裁剪（Weiler-Atherton算法）

操作方式与Sutherland-Hodgman算法相同，但使用Weiler-Atherton算法进行裁剪，能够更好地处理凹多边形。

---

## 五、功能模块结构及说明

### 5.1 系统架构


系统采用分层架构设计，主要包括以下几个层次：

```
┌─────────────────────────────────────────┐
│         用户界面层（UI Layer）            │
│    窗口过程、菜单处理、鼠标事件处理        │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│      图形引擎层（Graphics Engine）        │
│   GraphicsEngine - 核心绘图引擎           │
└─────────────────────────────────────────┘
                    ↓
┌──────────────┬──────────────┬──────────────┐
│  图形管理模块  │  变换管理模块  │  裁剪管理模块  │
│ ShapeManager │TransformMgr  │  ClipManager │
└──────────────┴──────────────┴──────────────┘
                    ↓
┌─────────────────────────────────────────┐
│         算法实现层（Algorithms）          │
│  LineDrawer, CircleDrawer, FillAlgorithms│
│  TransformAlgorithms, ClippingAlgorithms │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│       数据模型层（Data Model）            │
│    Shape, Point2D, Matrix3x3等数据结构   │
└─────────────────────────────────────────┘
```

### 5.2 类结构图

```
Shape (图形基类)
├── LineShape (直线)
├── CircleShape (圆)
├── RectangleShape (矩形)
├── PolylineShape (多段线)
├── PolygonShape (多边形)
└── BSplineShape (B样条曲线)

GraphicsEngine (图形引擎)
├── ShapeManager (图形管理器)
├── TransformManager (变换管理器)
└── ClipManager (裁剪管理器)

ClippingAlgorithms (裁剪算法类)
├── CohenSutherland (Cohen-Sutherland算法)
├── MidpointSubdivision (中点分割算法)
├── SutherlandHodgman (Sutherland-Hodgman算法)
└── WeilerAtherton (Weiler-Atherton算法)

TransformAlgorithms (变换算法类)
├── Translation (平移)
├── Scaling (缩放)
└── Rotation (旋转)
```

### 5.3 功能模块说明

#### 5.3.1 主程序模块（main.cpp）

**功能：** 程序入口，窗口创建，消息循环处理

**职责：**
- 创建主窗口和菜单系统
- 处理Windows消息（WM_CREATE, WM_PAINT, WM_COMMAND等）
- 响应菜单点击事件
- 处理鼠标事件（WM_LBUTTONDOWN, WM_RBUTTONDOWN, WM_MOUSEMOVE等）
- 将用户操作转发给图形引擎处理

#### 5.3.2 图形引擎模块（GraphicsEngine类）

**功能：** 核心绘图引擎，统一管理所有图形操作

**职责：**
- 维护当前绘图模式和操作状态
- 管理临时点集合和预览图形
- 协调各个子模块（图形管理、变换、裁剪）
- 处理鼠标输入并转换为图形操作
- 管理设备上下文（HDC）和双缓冲
- 提供统一的绘图接口

#### 5.3.3 图形管理模块（ShapeManager）

**功能：** 管理所有图形对象的生命周期

**职责：**
- 存储和管理所有已绘制的图形对象
- 实现图形的添加、删除和清空操作
- 实现图形选择功能（点击检测）
- 维护当前选中的图形状态
- 提供图形遍历和渲染接口
- 绘制选中图形的高亮效果

#### 5.3.4 变换管理模块（TransformManager）

**功能：** 处理图形的几何变换操作

**职责：**
- 管理变换操作的状态（平移、缩放、旋转）
- 处理变换操作的鼠标交互
- 计算变换矩阵
- 应用变换到选中的图形
- 提供实时预览功能

#### 5.3.5 裁剪管理模块（ClipManager）

**功能：** 处理图形的裁剪操作

**职责：**
- 管理裁剪窗口的定义
- 处理裁剪窗口的鼠标交互
- 调用相应的裁剪算法
- 更新被裁剪的图形对象
- 提供裁剪窗口的预览显示

#### 5.3.6 裁剪算法模块（ClippingAlgorithms类）

**功能：** 实现各种裁剪算法

**包含算法：**
- **Cohen-Sutherland算法**：使用区域编码快速裁剪直线
- **中点分割算法**：递归分割直线进行裁剪
- **Sutherland-Hodgman算法**：逐边裁剪多边形
- **Weiler-Atherton算法**：基于顶点链表追踪的多边形裁剪

#### 5.3.7 变换算法模块（TransformAlgorithms类）

**功能：** 实现几何变换算法

**包含算法：**
- **平移变换**：使用平移矩阵移动图形
- **缩放变换**：使用缩放矩阵改变图形大小
- **旋转变换**：使用旋转矩阵旋转图形

#### 5.3.8 图形对象模块（Shape类及其派生类）

**功能：** 定义各种图形类型的数据结构和行为

**包含类型：**
- **LineShape**：直线（存储两个端点）
- **CircleShape**：圆（存储圆心和半径）
- **RectangleShape**：矩形（存储对角顶点）
- **PolylineShape**：多段线（存储顶点序列）
- **PolygonShape**：多边形（存储顶点序列，自动闭合）
- **BSplineShape**：B样条曲线（存储控制点）

---

## 六、算法流程图及说明

### 6.1 Cohen-Sutherland直线裁剪算法

**算法原理：**

Cohen-Sutherland算法使用区域编码（outcode）快速判断线段与裁剪窗口的关系。将平面分为9个区域，每个区域用4位二进制编码表示：

```
1001 | 1000 | 1010
-----|------|-----
0001 | 0000 | 0010
-----|------|-----
0101 | 0100 | 0110
```

- 第1位（右）：点在窗口右侧
- 第2位（左）：点在窗口左侧
- 第3位（上）：点在窗口上方
- 第4位（下）：点在窗口下方

**算法流程：**

```
开始
  ↓
计算两端点的区域编码 code1, code2
  ↓
code1 | code2 == 0? ──是──→ 完全在窗口内，接受线段
  ↓否
code1 & code2 != 0? ──是──→ 完全在窗口外，拒绝线段
  ↓否
选择窗口外的端点
  ↓
计算该端点与窗口边界的交点
  ↓
用交点替换窗口外的端点
  ↓
重新计算区域编码，返回判断
```

**算法特点：**
- 优点：快速判断简单情况（完全内部或完全外部）
- 缺点：对于部分相交的线段需要多次迭代
- 时间复杂度：O(1)到O(n)，n为迭代次数

### 6.2 中点分割直线裁剪算法

**算法原理：**

中点分割算法采用递归分治的思想，不断将线段分割为两半，直到可以判断接受或拒绝。

**算法流程：**

```
开始
  ↓
两端点都在窗口内? ──是──→ 接受线段
  ↓否
两端点都在窗口外同侧? ──是──→ 拒绝线段
  ↓否
计算线段中点
  ↓
递归处理左半段
  ↓
递归处理右半段
  ↓
结束
```

**算法特点：**
- 优点：实现简单，不需要计算交点
- 缺点：递归深度可能较大，需要设置最大深度限制
- 时间复杂度：O(log n)，n为线段长度

### 6.3 Sutherland-Hodgman多边形裁剪算法

**算法原理：**

Sutherland-Hodgman算法依次对裁剪窗口的四条边进行裁剪，每次裁剪产生一个新的多边形。对于每条边，根据多边形边的两个端点与裁剪边的位置关系，有四种情况：

1. 两端点都在内侧：输出第二个端点
2. 第一个在内，第二个在外：输出交点
3. 第一个在外，第二个在内：输出交点和第二个端点
4. 两端点都在外侧：不输出

**算法流程：**

```
输入多边形
  ↓
对左边界裁剪 → 得到中间多边形1
  ↓
对右边界裁剪 → 得到中间多边形2
  ↓
对下边界裁剪 → 得到中间多边形3
  ↓
对上边界裁剪 → 得到最终多边形
  ↓
输出结果
```

**单边裁剪过程：**

```
遍历多边形的每条边
  ↓
获取边的两个端点 P1, P2
  ↓
判断P1和P2相对于裁剪边的位置
  ↓
根据四种情况输出相应的点
  ↓
继续下一条边
```

**算法特点：**
- 优点：实现简单，适用于凸多边形
- 缺点：对凹多边形可能产生多余的边
- 时间复杂度：O(n)，n为多边形顶点数

### 6.4 Weiler-Atherton多边形裁剪算法

**算法原理：**

Weiler-Atherton算法通过构建多边形和裁剪窗口的交点链表，然后追踪边界生成结果多边形。算法能够正确处理凹多边形和生成多个结果多边形。

**算法流程：**

```
开始
  ↓
计算多边形与窗口边界的所有交点
  ↓
将交点插入多边形顶点链表
  ↓
将交点插入窗口顶点链表
  ↓
标记每个交点的进入/离开属性
  ↓
从未访问的进入点开始追踪
  ↓
沿多边形边界前进到下一个交点
  ↓
切换到窗口边界
  ↓
沿窗口边界前进到下一个交点
  ↓
切换回多边形边界
  ↓
重复直到回到起点
  ↓
完成一个结果多边形
  ↓
还有未访问的进入点? ──是──→ 继续追踪
  ↓否
输出所有结果多边形
  ↓
结束
```

**交点标记规则：**
- 从多边形外部进入窗口内部的交点标记为"进入点"
- 从多边形内部离开窗口的交点标记为"离开点"

**算法特点：**
- 优点：能够正确处理凹多边形，可生成多个结果多边形
- 缺点：实现复杂，需要维护复杂的数据结构
- 时间复杂度：O(n + m + k)，n为多边形顶点数，m为窗口顶点数，k为交点数

---

## 七、核心代码及注释

### 7.1 Cohen-Sutherland直线裁剪算法实现


```cpp
// 【代码占位符：Cohen-Sutherland算法实现】
// 包含ComputeOutCode和ClipLineCohenSutherland函数
```

### 7.2 中点分割直线裁剪算法实现

```cpp
// 【代码占位符：中点分割算法实现】
// 包含ClipLineMidpointRecursive和ClipLineMidpoint函数
```

### 7.3 Sutherland-Hodgman多边形裁剪算法实现

```cpp
// 【代码占位符：Sutherland-Hodgman算法实现】
// 包含IsInsideEdge、ComputeIntersection、ClipPolygonAgainstEdge和ClipPolygonSutherlandHodgman函数
```

### 7.4 Weiler-Atherton多边形裁剪算法实现

```cpp
// 【代码占位符：Weiler-Atherton算法实现】
// 包含SegmentIntersection、BuildPolygonVertexList、BuildClipWindowVertexList、
// InsertIntersections、MarkEntryExit、TraceClippedPolygons和ClipPolygonWeilerAtherton函数
```

### 7.5 几何变换算法实现

```cpp
// 【代码占位符：几何变换算法实现】
// 包含平移、缩放、旋转的矩阵计算和应用函数
```

### 7.6 图形选择算法实现

```cpp
// 【代码占位符：图形选择算法实现】
// 包含点击检测、距离计算等函数
```

### 7.7 鼠标事件处理

```cpp
// 【代码占位符：鼠标事件处理代码】
// 包含OnLButtonDown、OnRButtonDown、OnMouseMove等事件处理函数
```

---

## 八、软件使用说明

### 8.1 系统要求

- **操作系统：** Windows 7及以上版本
- **开发环境：** Visual Studio 2019/2022
- **编译器：** MSVC (Microsoft Visual C++)
- **依赖库：** Windows SDK
- **屏幕分辨率：** 建议1920×1080或更高

### 8.2 编译与运行

1. 使用Visual Studio打开`ComputerGraphics.sln`解决方案文件
2. 选择配置（Debug或Release）和平台（x86或x64）
3. 按F5或点击"开始调试"按钮编译并运行程序
4. 程序启动后显示主窗口，可以开始使用各项功能

### 8.3 功能使用指南

#### 8.3.1 绘制多边形

1. 点击菜单"绘图" → "多边形（右键结束）"
2. 在画布上依次点击鼠标左键添加多边形的各个顶点
3. 点击鼠标右键或双击左键结束绘制
4. 程序自动闭合多边形并显示
5. **注意：** 至少需要3个顶点才能形成有效的多边形

#### 8.3.2 选择图形

1. 点击菜单"变换" → "选择图形"
2. 在画布上点击要选择的图形
3. 被选中的图形会以高亮方式显示（虚线边框或特殊颜色）
4. 点击空白区域可以取消选择
5. **提示：** 只有选中图形后才能进行变换操作

#### 8.3.3 平移图形

1. 先使用"选择图形"功能选中一个图形
2. 点击菜单"变换" → "平移"
3. 在画布上点击鼠标左键确定起始位置
4. 按住鼠标左键拖动到目标位置
5. 释放鼠标左键完成平移
6. **效果：** 图形会移动到新位置，保持形状和大小不变

#### 8.3.4 缩放图形

1. 先选中一个图形
2. 点击菜单"变换" → "缩放"
3. 点击鼠标左键确定缩放中心（默认为图形中心）
4. 向外拖动鼠标放大图形，向内拖动缩小图形
5. 释放鼠标左键完成缩放
6. **效果：** 图形大小改变，但形状比例保持不变

#### 8.3.5 旋转图形

1. 先选中一个图形
2. 点击菜单"变换" → "旋转"
3. 点击鼠标左键确定旋转中心
4. 移动鼠标，图形会实时旋转
5. 再次点击鼠标左键完成旋转
6. **效果：** 图形绕指定点旋转，保持大小和形状不变

#### 8.3.6 Cohen-Sutherland直线裁剪

1. 点击菜单"裁剪" → "直线裁剪" → "Cohen-Sutherland算法"
2. 在画布上按住鼠标左键并拖动，定义矩形裁剪窗口
3. 拖动过程中会显示虚线矩形预览
4. 释放鼠标后，程序自动对所有直线执行裁剪
5. **结果：** 只保留裁剪窗口内的直线段部分
6. **适用：** 仅对直线类型的图形有效

#### 8.3.7 中点分割直线裁剪

1. 点击菜单"裁剪" → "直线裁剪" → "中点分割算法"
2. 操作方式与Cohen-Sutherland算法相同
3. 使用递归中点分割方法进行裁剪
4. **特点：** 实现简单，适合教学演示

#### 8.3.8 Sutherland-Hodgman多边形裁剪

1. 点击菜单"裁剪" → "多边形裁剪" → "Sutherland-Hodgman算法"
2. 在画布上拖动鼠标定义矩形裁剪窗口
3. 释放鼠标后，程序自动对所有多边形执行裁剪
4. **结果：** 只保留裁剪窗口内的多边形部分
5. **适用：** 适合凸多边形，对凹多边形可能产生额外边

#### 8.3.9 Weiler-Atherton多边形裁剪

1. 点击菜单"裁剪" → "多边形裁剪" → "Weiler-Atherton算法"
2. 操作方式与Sutherland-Hodgman算法相同
3. 使用顶点链表追踪方法进行裁剪
4. **特点：** 能够正确处理凹多边形和复杂情况
5. **结果：** 可能生成多个结果多边形

#### 8.3.10 清空画布

1. 点击菜单"文件" → "新建"
2. 或按快捷键Ctrl+N
3. 画布将被清空，所有图形对象被删除
4. 可以重新开始绘制

#### 8.3.11 查看程序信息

1. 点击菜单"帮助" → "关于"
2. 显示程序信息、作者信息和实验内容

### 8.4 操作技巧

1. **图形绘制顺序：** 先绘制的图形在下层，后绘制的在上层
2. **选择精度：** 点击图形边界附近即可选中，不需要非常精确
3. **预览功能：** 所有变换和裁剪操作都有实时预览，便于调整
4. **撤销操作：** 如果操作失误，可以使用"新建"清空画布重新开始
5. **多次变换：** 可以对同一图形进行多次变换操作

### 8.5 常见问题

**Q1：为什么点击"平移"菜单没有反应？**
- A：需要先使用"选择图形"功能选中一个图形

**Q2：裁剪后图形消失了？**
- A：可能图形完全在裁剪窗口外，被完全裁剪掉了

**Q3：Weiler-Atherton算法裁剪后图形不正确？**
- A：确保多边形是按顺时针或逆时针顺序绘制的，不要有自交

**Q4：如何绘制复杂的凹多边形？**
- A：使用"多边形"功能，依次点击顶点，注意顶点顺序

**Q5：变换后图形变形了？**
- A：检查是否选择了正确的变换中心点

---

## 九、实验总结

### 9.1 实验成果

本次实验成功实现了一个功能完整的图形变换和裁剪系统，主要成果包括：

**算法实现：**
- 实现了Cohen-Sutherland和中点分割两种直线裁剪算法
- 实现了Sutherland-Hodgman和Weiler-Atherton两种多边形裁剪算法
- 实现了平移、缩放、旋转三种基本几何变换
- 实现了图形对象的选择和管理机制

**功能完善：**
- 支持多种图形类型的绘制和管理
- 提供友好的图形用户界面和菜单系统
- 支持鼠标交互式操作
- 实现了实时预览功能
- 提供了完整的错误处理机制

**系统架构：**
- 采用面向对象的设计方法
- 模块化的代码结构，易于维护和扩展
- 清晰的类层次结构
- 良好的代码注释和文档

### 9.2 技术收获

**算法理解：**
- 深入理解了齐次坐标和变换矩阵的数学原理
- 掌握了区域编码在裁剪算法中的应用
- 理解了递归分治思想在图形算法中的运用
- 掌握了顶点链表追踪的复杂算法实现

**编程能力：**
- 提高了C++面向对象编程能力
- 学会了设计和实现复杂的数据结构（如顶点链表）
- 掌握了Windows GDI图形编程技术
- 提高了代码调试和问题解决能力

**软件工程：**
- 学会了模块化设计和接口设计
- 掌握了事件驱动编程模式
- 理解了软件架构的重要性
- 提高了代码组织和文档编写能力

### 9.3 遇到的问题及解决

**问题1：Weiler-Atherton算法实现复杂**
- **现象：** 初次实现时，裁剪结果不正确，有时会把整个图形删除
- **原因：** 交点标记和追踪逻辑错误，没有正确处理进入点和离开点
- **解决：** 仔细分析算法流程，重新设计顶点链表结构，修正追踪逻辑

**问题2：图形选择不准确**
- **现象：** 点击图形附近时无法选中，或者选中了错误的图形
- **原因：** 点击检测算法的容差设置不合理
- **解决：** 调整容差参数，改进距离计算方法

**问题3：变换后图形位置偏移**
- **现象：** 缩放或旋转后，图形位置发生了意外的偏移
- **原因：** 变换中心点计算错误，没有正确应用复合变换矩阵
- **解决：** 使用"平移到原点-变换-平移回去"的标准流程

**问题4：裁剪算法性能问题**
- **现象：** 裁剪大量图形时程序响应缓慢
- **原因：** 没有优化算法，对所有图形都进行了完整的裁剪计算
- **解决：** 添加边界框预判断，快速排除明显不相交的图形

**问题5：内存泄漏**
- **现象：** 长时间运行后程序占用内存增加
- **原因：** Weiler-Atherton算法中动态分配的顶点没有正确释放
- **解决：** 使用智能指针或在算法结束时统一清理内存

### 9.4 心得体会

通过本次实验，我深刻体会到：

**理论与实践的结合：** 课堂上学习的几何变换和裁剪算法原理，通过编程实现后有了更深刻的理解。特别是Weiler-Atherton算法，只有在实际实现过程中才能真正理解其复杂性和巧妙之处。

**算法设计的重要性：** 不同的裁剪算法适用于不同的场景。Cohen-Sutherland算法简单高效，适合直线裁剪；Sutherland-Hodgman算法实现简单，适合凸多边形；Weiler-Atherton算法虽然复杂，但能处理更复杂的情况。选择合适的算法对系统性能和正确性至关重要。

**数据结构的作用：** 良好的数据结构设计能够大大简化算法实现。例如，使用顶点链表结构实现Weiler-Atherton算法，使得交点插入和边界追踪变得更加清晰。

**面向对象的优势：** 通过继承和多态，可以统一处理不同类型的图形对象，使代码更加简洁和可扩展。Shape基类的设计使得添加新的图形类型变得非常容易。

**调试技巧的提升：** 在实现复杂算法时，遇到了很多难以定位的bug。通过添加日志输出、可视化中间结果、单步调试等方法，逐步提高了调试效率。

**用户体验的重要性：** 实时预览、高亮显示、友好的错误提示等细节，大大提升了软件的可用性。一个好的软件不仅要功能正确，还要易于使用。

**持续学习的必要性：** 图形学是一个广阔的领域，本次实验只是冰山一角。通过实验，激发了我对图形学更深入学习的兴趣，也认识到需要不断学习新的算法和技术。

总的来说，本次实验是一次非常有价值的学习经历。不仅巩固了计算机图形学的理论知识，也提高了实际编程能力和软件工程素养。通过解决实际问题，培养了分析问题和解决问题的能力，为今后的学习和工作打下了良好的基础。

---

## 附录

### 附录A：主要数据结构定义

```cpp
// 【代码占位符：Point2D、Shape、Matrix3x3等数据结构定义】
```

### 附录B：菜单ID定义

```cpp
// 【代码占位符：MenuIDs.h中的菜单ID定义】
```

### 附录C：算法复杂度分析

| 算法名称 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|-----------|-----------|---------|
| Cohen-Sutherland | O(1)~O(n) | O(1) | 直线裁剪，快速判断 |
| 中点分割 | O(log L) | O(log L) | 直线裁剪，教学演示 |
| Sutherland-Hodgman | O(n) | O(n) | 凸多边形裁剪 |
| Weiler-Atherton | O(n+m+k) | O(n+m+k) | 任意多边形裁剪 |

注：n为多边形顶点数，m为窗口顶点数，k为交点数，L为线段长度

### 附录D：参考资料

1. 《计算机图形学》（第四版），Donald Hearn & M. Pauline Baker
2. 《计算机图形学原理及实践》（第三版），John F. Hughes等
3. Windows GDI编程文档，Microsoft官方文档
4. 各裁剪算法的原始论文和技术报告

### 附录E：实验截图

```
【图片占位符：主界面截图】
【图片占位符：多边形绘制截图】
【图片占位符：图形选择截图】
【图片占位符：平移变换截图】
【图片占位符：缩放变换截图】
【图片占位符：旋转变换截图】
【图片占位符：Cohen-Sutherland裁剪截图】
【图片占位符：中点分割裁剪截图】
【图片占位符：Sutherland-Hodgman裁剪截图】
【图片占位符：Weiler-Atherton裁剪截图】
```

---

**实验报告完成日期：** 2025年12月5日

**指导教师签字：** _______________

**成绩评定：** _______________
