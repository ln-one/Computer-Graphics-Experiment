# 计算机图形学综合实验 - 使用说明

**学号：** 2023112573  
**姓名：** 张春冉

## 项目概述

本项目是一个综合性的计算机图形学实验程序，包含了实验一和实验二的所有功能要求。

## 功能特性

### 实验一：基本图形绘制
- 绘制带圆角的矩形
- 绘制内部圆角矩形孔
- 绘制四个圆孔
- 精确的尺寸控制和比例缩放

### 实验二：基本图形生成算法

#### 直线绘制算法
1. **DDA算法** - 数字微分分析器算法
2. **Bresenham算法** - 整数运算的直线算法

#### 圆绘制算法
1. **中点圆算法** - 基于中点判别的圆绘制
2. **Bresenham圆算法** - 整数运算的圆绘制算法

#### 其他图形
1. **矩形** - 使用直线算法绘制矩形
2. **多段线** - 连续的线段绘制
3. **B样条曲线** - 基于控制点的平滑曲线

#### 填充算法
1. **扫描线填充** - 对封闭区域进行填充
2. **边界填充** - 基于边界颜色的区域填充

## 使用方法

### 菜单操作

#### 文件菜单
- **新建 (Ctrl+N)**: 清空画布
- **退出**: 关闭程序

#### 实验菜单
- **实验一：基本图形绘制**: 显示实验一的图形

#### 绘图菜单
- **直线(DDA算法)**: 选择DDA直线绘制模式
- **直线(Bresenham算法)**: 选择Bresenham直线绘制模式
- **圆(中点算法)**: 选择中点圆绘制模式
- **圆(Bresenham算法)**: 选择Bresenham圆绘制模式
- **矩形**: 选择矩形绘制模式
- **多段线(右键结束)**: 选择多段线绘制模式
- **B样条曲线(4个控制点)**: 选择B样条曲线绘制模式

#### 填充菜单
- **扫描线填充**: 选择扫描线填充模式
- **边界填充**: 选择边界填充模式

### 鼠标操作

#### 直线绘制
1. 选择直线绘制模式（DDA或Bresenham）
2. 在画布上点击确定起点
3. 再次点击确定终点，直线自动绘制

#### 圆绘制
1. 选择圆绘制模式（中点或Bresenham）
2. 在画布上点击确定圆心
3. 再次点击确定半径，圆自动绘制

#### 矩形绘制
1. 选择矩形绘制模式
2. 在画布上点击确定第一个角点
3. 再次点击确定对角点，矩形自动绘制

#### 多段线绘制
1. 选择多段线绘制模式
2. 依次点击各个顶点
3. 右键点击结束绘制

#### B样条曲线绘制
1. 选择B样条曲线绘制模式
2. 依次点击4个控制点
3. 曲线自动生成

#### 边界填充
1. 选择边界填充模式
2. 在封闭区域内部点击
3. 区域自动填充为红色

## 技术实现

### 算法详解

#### DDA直线算法
```cpp
void DrawLineDDA(Point2D p1, Point2D p2, COLORREF color) {
    int dx = p2.x - p1.x;
    int dy = p2.y - p1.y;
    int steps = abs(dx) > abs(dy) ? abs(dx) : abs(dy);
    
    float xIncrement = (float)dx / steps;
    float yIncrement = (float)dy / steps;
    
    float x = (float)p1.x;
    float y = (float)p1.y;
    
    for (int i = 0; i <= steps; i++) {
        SetPixel((int)(x + 0.5), (int)(y + 0.5), color);
        x += xIncrement;
        y += yIncrement;
    }
}
```

#### Bresenham直线算法
```cpp
void DrawLineBresenham(Point2D p1, Point2D p2, COLORREF color) {
    int dx = abs(p2.x - p1.x);
    int dy = abs(p2.y - p1.y);
    int sx = p1.x < p2.x ? 1 : -1;
    int sy = p1.y < p2.y ? 1 : -1;
    int err = dx - dy;
    
    int x = p1.x;
    int y = p1.y;
    
    while (true) {
        SetPixel(x, y, color);
        
        if (x == p2.x && y == p2.y) break;
        
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x += sx;
        }
        if (e2 < dx) {
            err += dx;
            y += sy;
        }
    }
}
```

#### 中点圆算法
```cpp
void DrawCircleMidpoint(Point2D center, int radius, COLORREF color) {
    int x = 0;
    int y = radius;
    int d = 1 - radius;
    
    while (x <= y) {
        // 绘制8个对称点
        SetPixel(center.x + x, center.y + y, color);
        SetPixel(center.x - x, center.y + y, color);
        SetPixel(center.x + x, center.y - y, color);
        SetPixel(center.x - x, center.y - y, color);
        SetPixel(center.x + y, center.y + x, color);
        SetPixel(center.x - y, center.y + x, color);
        SetPixel(center.x + y, center.y - x, color);
        SetPixel(center.x - y, center.y - x, color);
        
        if (d < 0) {
            d += 2 * x + 3;
        } else {
            d += 2 * (x - y) + 5;
            y--;
        }
        x++;
    }
}
```

### 项目结构
```
Expr-1/
├── Expr-1/
│   ├── Expr-1.cpp          # 主程序文件
│   ├── Expr-1.h            # 主程序头文件
│   ├── GraphicsEngine.h    # 图形引擎头文件
│   ├── GraphicsEngine.cpp  # 图形引擎实现
│   ├── framework.h         # Windows框架头文件
│   ├── resource.h          # 资源定义
│   └── ...                 # 其他VS项目文件
└── 使用说明.md             # 本文档
```

## 编译和运行

1. 使用Visual Studio 2022打开`Expr-1.sln`
2. 选择Debug或Release配置
3. 按F5编译并运行程序

## 注意事项

1. 程序需要在Windows环境下运行
2. 使用Visual Studio 2022或更高版本编译
3. 确保Windows SDK已正确安装
4. 多段线绘制时使用右键结束
5. B样条曲线需要至少4个控制点
6. 边界填充适用于封闭的黑色边界区域

## 实验报告要点

本程序完全满足实验二的所有要求：

1. ✅ 基本图形绘制（直线、曲线、圆、矩形、多段线）
2. ✅ 中点法和Bresenham算法实现直线段绘制
3. ✅ 中点法和Bresenham算法实现圆的绘制
4. ✅ 扫描线法和边界填充法实现封闭区域填充
5. ✅ B样条曲线绘制功能
6. ✅ 完整的用户界面和交互方式
7. ✅ 详细的算法实现和代码注释